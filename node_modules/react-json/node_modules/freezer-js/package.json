{
  "name": "freezer-js",
  "version": "0.5.2",
  "description": "A tree data structure that is always updated from the root, making easier to think in a reactive way.",
  "main": "freezer.js",
  "homepage": "https://github.com/arqex/freezer",
  "scripts": {
    "test": "node ./node_modules/mocha/bin/mocha tests",
    "build": "node ./node_modules/gulp/bin/gulp.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/arqex/freezer.git"
  },
  "keywords": [
    "react",
    "reactive",
    "store",
    "flux",
    "state",
    "cursor",
    "tree"
  ],
  "author": {
    "name": "arqex"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/arqex/freezer/issues"
  },
  "devDependencies": {
    "mocha": "~2.0.1",
    "unit.js": "~1.0.2",
    "gulp-uglify": "~1.0.1",
    "gulp-rename": "~1.2.0",
    "gulp-insert": "~0.4.0",
    "gulp": "~3.8.11",
    "benchmark": "~1.0.0",
    "immutable": "~3.6.2",
    "chai": "~2.0.0"
  },
  "readme": "# Freezer\r\n\r\nA tree data structure that is always updated from the root, even if the modification is triggered by one of the leaves, making easier to think in a reactive way.\r\n\r\n[![Build Status](https://secure.travis-ci.org/arqex/freezer.svg)](https://travis-ci.org/arqex/freezer)\r\n[![npm version](https://badge.fury.io/js/freezer-js.svg)](http://badge.fury.io/js/freezer-js)\r\n\r\nFreezer is made with React.js in mind and uses real immutable structures, it is the perfect store for your Flux implementation. \r\n\r\nWhat makes Freezer special is:\r\n\r\n* Immutable trees to make fast comparison among nodes.\r\n* Eventful nodes to notify updates to other parts of the app.\r\n* No dependencies.\r\n* Lightweight: ~7KB minified (much less if gzipped).\r\n* Packaged as UMD module to be loaded everywhere.\r\n* Uses common JS array and objects to store the data.\r\n\r\nDo you want to know more?\r\n\r\n* [Demos](#demos)\r\n* [Installation](#installation)\r\n* [Example](#example-of-use)\r\n* [Motivation](#why-another-store)\r\n* [Freezer API](#api)\r\n* [Updating the data](#update-methods)\r\n* [Events](#events-1)\r\n* [Batch updates](#batch-updates)\r\n* [Changelog](#changelog)\r\n\r\n## Demos\r\n* [You can **test** freezer.js in this JSbin](http://jsbin.com/fedeva/4/edit?js,console)\r\n* [A JSON editor with undo and redo](http://jsbin.com/hugusi/1/edit?js,output), and [here the blog article](http://arqex.com/991/json-editor-react-immutable-data) explaining it \r\n\r\n## Installation\r\nFreezer is available as a npm package.\r\n```\r\nnpm install freezer-js\r\n```\r\n\r\nAlso as a bower package\r\n```\r\nbower install freezer-js\r\n```\r\n\r\nIt is possible to download the [full version](https://raw.githubusercontent.com/arqex/freezer/master/build/freezer.js) (~13KB) or [minified](https://raw.githubusercontent.com/arqex/freezer/master/build/freezer.min.js) (~7KB).\r\n\r\n## Example of use\r\nYou can play with [this example in JSBin](http://jsbin.com/suvoxivizi/2/edit?js,console).\r\n```js\r\n// Browserify/Node style of loading\r\nvar Freezer = require('freezer-js');\r\n\r\n// Let's create a freezer store\r\nvar store = new Freezer({\r\n    a: {x: 1, y: 2, z: [0, 1, 2] },\r\n    b: [ 5, 6, 7 , { m: 1, n: 2 } ],\r\n    c: 'Hola',\r\n    d: null // It is possible to store whatever\r\n});\r\n\r\n// Let's get the frozen data stored\r\nvar data = store.get();\r\n\r\n// Listen to changes in the store\r\nstore.on('update', function( newValue ){\r\n    // New value will have the updated store's data\r\n    console.log( 'I was updated' );\r\n});\r\n\r\n// The data is read as usual\r\nconsole.log( data.c ); // logs 'Hola'\r\n\r\n// And used as usual\r\ndata.a.z.forEach( function( item ){\r\n    console.log( item );\r\n}); // logs 0, 1 and 2\r\n\r\n// But it is immutable, so...\r\ndata.d = 3; console.log( data.d ); // logs null\r\ndata.e = 4; console.log( data.e ); // logs undefined\r\n\r\n// to update, use methods like set that returns new frozen data\r\nvar updated = data.set( 'e', 4 ); // On next tick it will log 'I was updated'\r\n\r\nconsole.log( data.e ); // Still logs undefined\r\nconsole.log( updated.e ); // logs 4\r\n\r\n// Store data has changed!\r\nstore.get() !== data; // true\r\nstore.get() === updated; // true\r\n\r\n// The nodes that weren't updated are reused\r\ndata.a === updated.a; // true\r\ndata.b === updated.b; // true\r\n\r\n// Updates can be chained because the new immutable\r\n// data node is always returned\r\nvar updatedB = updated.b.push( 100 )\r\n    .shift()\r\n    .set(0, 'Updated')\r\n; // It will log 'I was updated' on next tick, just once\r\n\r\n// updatedB is the current b property\r\nstore.get().b === updatedB; // true\r\n\r\n// And it is different from the one that started\r\nupdated !== store.get(); // true\r\nupdated.b !== updatedB; // true\r\nconsole.log( updated.b[0] ); // updated did't/can't change: logs 5\r\nconsole.log( updatedB[0] ); // logs 'Updated'\r\nconsole.log( updatedB[4] ); // logs 100\r\nupdatedB.length === 5; // true: We added 2 elements and removed 1\r\n\r\n// Untouched nodes are still the same\r\ndata.a === store.get().a; // still true\r\nupdated.a === store.get().a; // still true\r\n\r\n// Reverting to a previous state is as easy as\r\n// set the data again (Undo/redo made easy)\r\nstore.set( data ); // It will log 'I was updated' on next tick\r\n\r\nstore.get() === data; // true\r\n```\r\n\r\n\r\n## Why another store?\r\n\r\n**Freezer** is inspired by other tree cursor libraries, specially [Cortex](https://github.com/mquan/cortex) that try to solve an inconvenient of the Flux architecture:\r\n\r\n* If you have a store with deep nested data and you need to update some value from a child component that reflect that data, you need to dispatch an action and from the top of the store look for the bit of data again to update it. That may involve a lot of extra code to propagate the change and it is more painful when you think that the component knew already what data to update.\r\n\r\nIn the other hand, data changes always flowing in the same direction is what make Flux architecure so easy to reason about. If we let every component to update the data independently we are building a mess again.\r\n\r\nSo *Freezer*, instead of letting the child component to update the data directly, gives in every node the tools to require the change. The updates are always made by the root of the store and the data can keep flowing just in one direction.\r\n\r\nImagine that we have the following tree structure as our app store: ![Initial tree](img/initialTree.png)\r\n\r\nAnd we have a component responsible of handling the `store.c.f` ( the yellow node ) part of the data. Its scope is just that part of the tree, so the component receives it as a prop:\r\n```js\r\n// The component receives a part of the freezer data\r\nthis.props.branch = { h: 4, i: 5};\r\n```\r\nEventually the component is used to update `store.c.f.h = 8`. You can dispatch an action with the frozen node as the payload ( making easier for your actions know what to update ), or even use the node itself to require the change:\r\n```js\r\nthis.props.branch.set( {h: 8} );\r\n```\r\nThen, *Freezer* will create a new immutable data structure starting from the top of the tree, and our component will receive a new branch to render. The store finished like this: ![Updated tree](img/updatedTree.png)\r\n\r\nSince the whole tree is updated, we can have the main app state in one single object and make the top level components re-render in a reactive way to changes that are made deep in the store hierarchy.\r\n\r\n**Freezer** is very influenced by the way that [Facebook's Immutable](https://github.com/facebook/immutable-js) handles immutabilty. It creates a new tree every time that a modification is required referencing the non modified nodes from the previous tree. Sharing node references among frozen objects saves memory and boost the performance on creating new frozens.\r\n\r\nUsing immutability with React is great, because you don't need to make deep comparisons in order to know when to update a component:\r\n```js\r\nshouldComponentUpdate: function( nextProps ){\r\n\r\n    // The comparison is fast, and we won't render the component if\r\n    // it does not need it. This is a huge gain in performance.\r\n    return this.props.store != nextProps.store;\r\n}\r\n```\r\n\r\n*Freezer* has less features than *Immutable*, but its API is simpler and it is much more lightweight (Minified, Immutable is ~56KB and Freezer ~7KB).\r\n\r\nInstead on learning the set of methods needed to use *Immutable*, *Freezer* uses common JS objects and arrays to store the data, so you can start using it right now.\r\n\r\n## API\r\n\r\nCreate a freezer object using the constructor:\r\n```js\r\nvar store = new Freezer({a: 'hola', b:[1,2, [3,4,5]], c: false });\r\n```\r\nAnd then, Freezer API is really simple and only have 2 methods: `get` and `set`. A freezer object also implements the [listener API](#listener-api).\r\n\r\n#### get()\r\n\r\nReturns an frozen object with the freezer data.\r\n```js\r\n// Logs: {a: 'hola', b:[1,2, [3,4,5]], c: false }\r\nconsole.log( store.get() ); \r\n```\r\nThe data returned is actually formed by arrays and objects, but they are sealed to prevent their mutation and they have some methods in them to update the store.\r\nEverytime an update is performed, `get` will return a new frozen object.\r\n\r\n#### set( data )\r\n\r\nReplace the current frozen data with new one.\r\n```js\r\n\r\n// An example on how to undo an update would be like this...\r\nvar store = new Freezer({a: 'hola', b:[1,2, [3,4,5]], c: false }),\r\n    data = store.get()\r\n;\r\n\r\nvar updated = data.set({c: true});\r\nconsole.log( updated.c ); // true\r\n\r\n// Restore the inital state\r\nstore.set( data );\r\nconsole.log( store.get().c ); // false\r\n```\r\n\r\n#### Events\r\n\r\nEvery time that the data is updated, an `update` event is triggered on the store. In order to use those events, *Freezer* stores implement the [listener API](#listener-api), and `on`, `once` and `off` methods are available on them.\r\n\r\n## Update methods\r\n\r\nFreezer data has three different types of nodes: *Hashes*, *Arrays* and *leaf nodes*. A leaf node can't be updated by itself and it need to be updated using its parent node. Every updating method return a new immutable object with the new node result of the update:\r\n```js\r\nvar store = new Freezer({obj: {a:'hola', b:'adios'}, arr: [1,2]});\r\n\r\nvar updatedObj = store.get().obj.set('a', 'hello');\r\nconsole.log( updatedObj ); // {a:'hello', b:'adios'}\r\n\r\nvar updatedArr = store.get().arr.unshift( 0 );\r\nconsole.log( udpatedArr ); // [0,1,2]\r\n\r\n// {obj: {a:'hello', b:'adios'}, arr: [0,1,2]}\r\nconsole.log( store.get() ); \r\n```\r\n\r\n Both, *Array* and *Hashes* nodes have a `set` method to update or add elements to the node and a `reset` method to replace the node by other data.\r\n\r\n#### set( keyOrHash, value )\r\nArrays and hashes can update their children using the `set` method. It accepts a hash with the keys and values to update or two arguments, the key and the value.\r\n```js\r\nvar store = new Freezer({obj: {a:'hola', b:'adios'}, arr: [1,2]});\r\n\r\n// Updating using a hash\r\nstore.get().obj.set( {b:'bye', c:'ciao'} );\r\n\r\n// Updating using key and value\r\nstore.get().arr.set( 0, 0 );\r\n\r\n// {obj: {a:'hola', b:'bye', c:'ciao'}, arr: [0,2]}\r\nconsole.log( store.get() )\r\n```\r\n\r\n#### reset( newData )\r\nReset/replaces the node with new data. Listeners are preserved if the new data is an `array` or `object`, so it is possible to listen to reset calls. \r\n\r\n```js\r\nvar store = new Freezer({ foobar: {a: 'a', b: 'b', c: [0, 1, 2] } });\r\n\r\nvar newfoobar = { foo: 'bar', bar: 'foo' };\r\n\r\nvar reset = data.foobar.reset(newfoobar);\r\n\r\nconsole.log( reset ); //{ foo: 'bar', bar: 'foo' }\r\n```\r\n\r\n#### toJS()\r\n*Freezer* nodes are immutable. `toJS` transform *Freezer* nodes to plain mutable JS objects in case you need them.\r\n```js\r\n// Require node.js assert\r\nvar assert = require('assert');\r\n\r\nvar data = {obj: {a:'hola', b:'adios'}, arr: [1,2]},\r\n    store = new Freezer( data )\r\n;\r\n\r\nassert.deepEqual( data, store.get().toJS ); // Ok\r\n```\r\n\r\n## Hash methods\r\n#### remove( keyOrKeys )\r\nRemoves elements from a hash node. It accepts a string or an array with the names of the strings to remove.\r\n\r\n```js\r\nvar store = new Freezer({a:'hola', b:'adios', c:'hello', d:'bye'});\r\n\r\nvar updated = store.get()\r\n    .remove('d') // Removing an element\r\n    .remove(['b', 'c']) // Removing two elements\r\n;\r\n\r\nconsole.log( updated ); //{a: 'hola'}\r\n```\r\n\r\n\r\n## Array methods\r\nArray nodes have modified versions of the `push`, `pop`, `unshift`, `shift` and `splice` methods that update the cursor and return the new node, instead of updating the immutable array node ( that would be impossible ).\r\n```js\r\nvar store = new Freezer({ arr: [0,1,2,3,4] });\r\n\r\nstore.get().arr\r\n    .push( 5 ) // [0,1,2,3,4,5]\r\n    .pop() // [0,1,2,3,4]\r\n    .unshift( 'a' ) // ['a',0,1,2,3,4]\r\n    .shift() // [0,1,2,3,4]\r\n    .splice( 1, 1, 'a', 'b') // [ 0, 'a', 'b', 2, 3, 4]\r\n;\r\n```\r\n\r\nArray nodes also have the `append` and `prepend` methods to batch insert elements at the begining or the end of the array.\r\n```js\r\nvar store = new Freezer({ arr: [2] });\r\n\r\nstore.get().arr\r\n    .prepend([0,1]) // [0,1,2]\r\n    .append([3,4]) // [0,1,2,3,4]\r\n;\r\n```\r\n\r\n## Events\r\nFreezer objects emit `update` events whenever their data changes. It is also possible to listen to `update` events in a intermediate node by creating a listener on it using the method `getListener`.\r\n\r\n#### getListener()\r\nReturns a listener that emits an `update` event when the node is updated. The listener implements the [listener API](#listener-api).\r\n```js\r\nvar store = new Cursor({ arr: [2] }),\r\n    data = store.get(),\r\n    listener = data.arr.getListener()\r\n;\r\n\r\nlistener.on('update', function( data ){\r\n    console.log( 'Updated!' );\r\n    console.log( data );\r\n});\r\n\r\ndata.arr.push( 3 ); //logs 'Updated!' [2,3]\r\n```\r\n\r\n## Listener API\r\nFreezer stores and listeners implement this API that is influenced by the way Backbone handle events. The only event that Freezer emits is `update`, end is emitted on every store/node update.\r\n\r\n#### on( eventName, callback )\r\nRegister a function to be called when an event occurs.\r\n#### once( eventName, callback )\r\nRegister a function to be called once when an event occurs. After being called the callback is unregistered.\r\n#### off( eventName, callback )\r\nCan unregister all callbacks from a listener if the `eventName` parameter is omitted, or all the callbacks for a `eventName` if the `callback` parameter is omitted.\r\n#### trigger( eventName [, param, param, ...] )\r\nTrigger an event on the listener. All the extra parameters will be passed to the registered callbacks.\r\n\r\n## Batch updates\r\nAt some point you will find yourself wanting to apply multiple changes on some node at a time. On every change the full tree is re-generated, but probably the only tree needed is the final result of all those changes. \r\n\r\nFreezer nodes offer a `transact` method to make local modifications to them without generating intermediate frozen trees, and a `run` method to commit all the changes at once. This way your app can have a really good performance.\r\n\r\n```js\r\nvar frozen = new Freezer({list:[]}),\r\n    data = frozen.get()\r\n;\r\n\r\n// transact returns a mutable object\r\n// to make all the local changes\r\nvar trans = data.list.transact();\r\n\r\n// trans is a common array\r\nfor( var i = 0; i < 1000; i++ )\r\n    trans.push(i);\r\n\r\n// use it as a normal array\r\ntrans[0] = 1000; // [1000, 1, 2, ..., 999]\r\n\r\n// the store does not know about the yet\r\nfrozen.get().list.length == 0; // true\r\n\r\n// to commit the changes use the run method in the node\r\ndata.list.run();\r\n\r\n// all the changes are made at once\r\nfrozen.get().list; // [1000, 1, 2, ..., 999]\r\n```\r\n\r\nTransactions are designed to always commit the changes, so if you start a transaction but you forget to call `run`, it will be called automatically on the next tick.\r\n\r\nIt is possible to update children nodes of a node that is making a transaction, but it is not really recommended. Those updates will not update the store until the transaction in the parent node is commited, and that may lead to confussion if you use child nodes as common freezer nodes. Updating child nodes doesn't improve its performance much because of having a transacting parent, so it is recommended to make the changes in the transaction node and run it as soon as you have finished with the modifications to prevent undesired behavior. \r\n\r\n## Changelog\r\n[Here](https://github.com/arqex/freezer/blob/master/CHANGELOG.md)\r\n",
  "readmeFilename": "README.md",
  "_id": "freezer-js@0.5.2",
  "_from": "freezer-js@^0.5.2"
}
